using UnityEngine;

namespace FIMSpace.FSpine
{
    public partial class FSpineAnimator
    {
        // PIVOT OFFSET WITH ADDITIONAL TRANSFORM \\


        /// <summary>
        /// Destroying pivot offset object generated by component
        /// </summary>
        void RemovePivotOffset()
        {
            if (Application.isPlaying)
            {
                if (mainPivotOffsetTransform)
                {
                    RestoreBasePivotChildren();
                    Destroy(mainPivotOffsetTransform.gameObject);
                }
            }
            else
            {
                if (mainPivotOffsetTransform)
                {
                    RestoreBasePivotChildren();
                    //DestroyImmediate(mainPivotOffsetTransform.gameObject);
                }
            }
        }


        /// <summary>
        /// Updating pivot offset object
        /// </summary>
        public void UpdatePivotOffsetState()
        {
            if (SpineBones.Count <= 1) return;

            if (MainPivotOffset == Vector3.zero)
            {
                if (mainPivotOffsetTransform)
                {
                    if (mainPivotOffsetTransform.childCount > 0)
                    {
                        mainPivotOffsetTransform.localPosition = MainPivotOffset;
                        RestoreBasePivotChildren();
                    }

                    // We can't destroy objects in OnValidate so transform will be left here in case you will use it again
                    //if (Application.isPlaying) Destroy(mainPivotOffsetTransform.gameObject); else DestroyImmediate(mainPivotOffsetTransform.gameObject);
                }
            }
            else
            {
                // Generating pivot offset transform - quickest way without defining other stuff
                if (!mainPivotOffsetTransform)
                {
                    mainPivotOffsetTransform = new GameObject("Main Pivot Offset-Spine Animator-" + name).transform;
                    mainPivotOffsetTransform.SetParent(GetBaseTransform(), false);
                    mainPivotOffsetTransform.localPosition = Vector3.zero;
                    mainPivotOffsetTransform.localRotation = Quaternion.identity;
                    mainPivotOffsetTransform.localScale = Vector3.one;
                }

                if (mainPivotOffsetTransform.childCount == 0)
                {
                    for (int i = GetBaseTransform().childCount - 1; i >= 0; i--)
                    {
                        if (GetBaseTransform().GetChild(i) == mainPivotOffsetTransform) continue;
                        GetBaseTransform().GetChild(i).SetParent(mainPivotOffsetTransform, true);
                    }
                }

                mainPivotOffsetTransform.localPosition = MainPivotOffset;
            }
        }


        /// <summary>
        /// Restoring generated pivot transform children to initial state
        /// </summary>
        void RestoreBasePivotChildren()
        {
            if (_editor_isQuitting) return;

            for (int i = mainPivotOffsetTransform.childCount - 1; i >= 0; i--)
                mainPivotOffsetTransform.GetChild(i).SetParent(mainPivotOffsetTransform.parent, true);
        }




        // PIVOT OFFSETS IN CHAIN \\

        /// <summary>
        /// Applying coordinates offsets for bones when it should affect children
        /// </summary>
        void PreMotionBoneOffsets()
        {
            if (!UseCorrections) return;

            if (ManualAffectChain)
            {
                PreMotionNoHead();
                PreMotionHead();
            }
        }

        void PreMotionNoHead()
        {
            if (SegmentsPivotOffset.sqrMagnitude != 0)
                for (int i = 1 - chainIndexOffset; i < SpineBones.Count - chainIndexOffset; ++i)
                    SegmentPreOffsetWithPivot(i);
            else
                for (int i = 1 - chainIndexOffset; i < SpineBones.Count - chainIndexOffset; ++i)
                    SegmentPreOffset(i);
        }

        void PreMotionHead()
        {
            if (SegmentsPivotOffset.sqrMagnitude != 0)
                SegmentPreOffsetWithPivot(leadingBoneIndex);
            else
                SegmentPreOffset(leadingBoneIndex);
        }

        void SegmentPreOffset(int i)
        {
            if (SpineBones[i].ManualPosOffset.sqrMagnitude != 0) SpineBones[i].transform.position += SpineBones[i].ProceduralRotation * (SpineBones[i].ManualPosOffset);
            SpineBones[i].transform.rotation *= SpineBones[i].ManualRotOffset;
        }

        void SegmentPreOffsetWithPivot(int i)
        {
            if (SpineBones[i].ManualPosOffset.sqrMagnitude != 0) SpineBones[i].transform.position += SpineBones[i].ProceduralRotation * (SpineBones[i].ManualPosOffset);
            SpineBones[i].transform.position += SpineBones[i].ProceduralRotation * (SegmentsPivotOffset * (SpineBones[i].BoneLength * DistancesMultiplier * BaseTransform.lossyScale.z));
            SpineBones[i].transform.rotation *= SpineBones[i].ManualRotOffset;
        }




        /// <summary>
        /// Applying coordinates offsets for bones when it should not affect children
        /// </summary>
        void PostMotionBoneOffsets()
        {
            if (!UseCorrections) return;

            // Giving possibility to manual correction for bones rotations and positions in spine chain
            if (!ManualAffectChain)
            {
                PostMotionHead();
                PostMotionNoHead();
            }
        }

        void PostMotionNoHead()
        {
            if (SegmentsPivotOffset.sqrMagnitude != 0)
                for (int i = 1 - chainIndexOffset; i < SpineBones.Count - chainIndexOffset; ++i)
                    SegmentPostOffsetWithPivot(i);
            else
                for (int i = 1 - chainIndexOffset; i < SpineBones.Count - chainIndexOffset; ++i)
                    SegmentPostOffset(i);
        }

        void PostMotionHead()
        {
            if (SegmentsPivotOffset.sqrMagnitude != 0)
                SegmentPostOffsetWithPivot(leadingBoneIndex);
            else
                SegmentPostOffset(leadingBoneIndex);
        }

        void SegmentPostOffset(int i)
        {
            if (SpineBones[i].ManualPosOffset.sqrMagnitude != 0) SpineBones[i].FinalPosition += SpineBones[i].ProceduralRotation * (SpineBones[i].ManualPosOffset);
            SpineBones[i].FinalRotation *= SpineBones[i].ManualRotOffset;
        }

        void SegmentPostOffsetWithPivot(int i)
        {
            if (SpineBones[i].ManualPosOffset.sqrMagnitude != 0) SpineBones[i].FinalPosition += SpineBones[i].ProceduralRotation * (SpineBones[i].ManualPosOffset);
            SpineBones[i].FinalPosition += SpineBones[i].ProceduralRotation * (SegmentsPivotOffset * (SpineBones[i].BoneLength * DistancesMultiplier * BaseTransform.lossyScale.z));
            SpineBones[i].FinalRotation *= SpineBones[i].ManualRotOffset;
        }



    }
}